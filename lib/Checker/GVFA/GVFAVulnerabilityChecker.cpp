/*

@Author: rainoftime
*/
#include "Checker/GVFA/GVFAVulnerabilityChecker.h"
#include "Analysis/GVFA/GlobalValueFlowAnalysis.h"
#include "Checker/Report/BugReport.h"
#include "Checker/Report/BugReportMgr.h"
#include <llvm/IR/Instructions.h>
#include <llvm/Support/raw_ostream.h>

void GVFAVulnerabilityChecker::reportVulnerability(
    int bugTypeId, const Value *Source, const Value *Sink, 
    const std::set<const Value *> *SinkInsts) {
    
    BugReport* report = new BugReport(bugTypeId);
    int trace_level = 0;
    
    // Source step
    if (auto *SourceInst = dyn_cast<Instruction>(Source)) {
        std::vector<NodeTag> tags;
        if (isa<CallInst>(SourceInst)) {
            tags.push_back(NodeTag::CALL_SITE);
        }
        report->append_step(const_cast<Instruction*>(SourceInst), 
                           "Vulnerability source", trace_level, tags, "source");
        trace_level++;
    } else {
        // For constants or non-instructions, try to find a proxy
        if (SinkInsts && !SinkInsts->empty()) {
            if (auto *FirstSinkInst = dyn_cast<Instruction>(*SinkInsts->begin())) {
                std::string sourceDesc = "Source: ";
                llvm::raw_string_ostream OS(sourceDesc);
                Source->print(OS);
                report->append_step(const_cast<Instruction*>(FirstSinkInst), 
                                   OS.str(), trace_level, {}, "source");
                trace_level++;
            }
        }
    }
    
    // Propagation path
    if (GVFA && Sink) {
        try {
            std::vector<const Value *> witnessPath = GVFA->getWitnessPath(Source, Sink);
            if (witnessPath.size() > 2) {
                for (size_t i = 1; i + 1 < witnessPath.size(); ++i) {
                    const Value *V = witnessPath[i];
                    if (!V) continue;
                    if (auto *I = dyn_cast<Instruction>(V)) {
                        std::vector<NodeTag> tags;
                        if (isa<CallInst>(I)) {
                            tags.push_back(NodeTag::CALL_SITE);
                            trace_level++;
                        }
                        std::string access = "propagation";
                        if (isa<StoreInst>(I)) access = "store";
                        else if (isa<LoadInst>(I)) access = "load";
                        report->append_step(const_cast<Instruction*>(I), 
                                           "Value propagates through here", 
                                           trace_level, tags, access);
                    }
                }
            }
        } catch (...) {}
    }
    
    // Sink step
    if (SinkInsts) {
        for (const Value *SI : *SinkInsts) {
            if (auto *SinkInst = dyn_cast<Instruction>(SI)) {
                std::vector<NodeTag> tags;
                if (isa<CallInst>(SinkInst)) {
                    tags.push_back(NodeTag::CALL_SITE);
                }
                std::string access = "sink";
                if (isa<LoadInst>(SinkInst)) access = "load";
                else if (isa<StoreInst>(SinkInst)) access = "store";
                report->append_step(const_cast<Instruction*>(SinkInst), 
                                   "Vulnerability sink", trace_level, tags, access);
            }
        }
    }
    
    report->set_conf_score(70);
    report->add_metadata("checker", "GVFAVulnerabilityChecker");
    report->add_metadata("category", getCategory());
    BugReportMgr::get_instance().insert_report(bugTypeId, report, true);
}

int GVFAVulnerabilityChecker::detectAndReport(
    Module *M, DyckGlobalValueFlowAnalysis *GVFA,
    bool contextSensitive, bool verbose) {
    
    this->GVFA = GVFA;
    int bugTypeId = registerBugType();
    
    VulnerabilitySourcesType Sources;
    VulnerabilitySinksType Sinks;
    getSources(M, Sources);
    getSinks(M, Sinks);
    
    int vulnCount = 0;
    
    for (const auto &SinkPair : Sinks) {
        const Value *SinkValue = SinkPair.first;
        const std::set<const Value *> *SinkInsts = SinkPair.second;
        
        for (const auto &SourceEntry : Sources) {
            const Value *SourceValue = SourceEntry.first.first;
            int SourceMask = SourceEntry.second;
            
            bool reachable = contextSensitive 
                ? GVFA->contextSensitiveReachable(SourceValue, SinkValue)
                : GVFA->reachable(SinkValue, SourceMask);
            
            if (reachable) {
                vulnCount++;
                reportVulnerability(bugTypeId, SourceValue, SinkValue, SinkInsts);
                
                if (verbose) {
                    llvm::outs() << "VULNERABILITY: " << getCategory() << "\n";
                    // Basic verbose output
                }
            }
        }
    }
    
    return vulnCount;
}

