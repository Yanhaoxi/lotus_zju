/*

@Author: rainoftime
*/
#include "Checker/GVFA/GVFAVulnerabilityChecker.h"
#include "Checker/Report/BugReportMgr.h"
#include "Checker/Report/BugReport.h"
#include "Analysis/GVFA/GlobalValueFlowAnalysis.h"
#include <llvm/Support/raw_ostream.h>
#include <llvm/IR/Instructions.h>

void GVFAVulnerabilityChecker::reportVulnerability(
    int bugTypeId, const Value *Source, const Value *Sink, 
    const std::set<const Value *> *SinkInsts) {
    
    BugReport* report = new BugReport(bugTypeId);
    
    // Default implementation of report generation
    // Derived classes can override this for specific reporting needs
    
    if (auto *SourceInst = dyn_cast<Instruction>(Source)) {
        report->append_step(const_cast<Instruction*>(SourceInst), "Source");
    } else {
        // For constants or non-instructions, try to find a proxy
        if (SinkInsts && !SinkInsts->empty()) {
            if (auto *FirstSinkInst = dyn_cast<Instruction>(*SinkInsts->begin())) {
                std::string sourceDesc = "Source: ";
                llvm::raw_string_ostream OS(sourceDesc);
                Source->print(OS);
                report->append_step(const_cast<Instruction*>(FirstSinkInst), OS.str());
            }
        }
    }
    
    if (GVFA && Sink) {
        try {
            std::vector<const Value *> witnessPath = GVFA->getWitnessPath(Source, Sink);
            if (witnessPath.size() > 2) {
                for (size_t i = 1; i + 1 < witnessPath.size(); ++i) {
                    const Value *V = witnessPath[i];
                    if (!V) continue;
                    if (auto *I = dyn_cast<Instruction>(V)) {
                        report->append_step(const_cast<Instruction*>(I), "Propagation");
                    }
                }
            }
        } catch (...) {}
    }
    
    if (SinkInsts) {
        for (const Value *SI : *SinkInsts) {
            if (auto *SinkInst = dyn_cast<Instruction>(SI)) {
                report->append_step(const_cast<Instruction*>(SinkInst), "Sink");
            }
        }
    }
    
    report->set_conf_score(70);
    BugReportMgr::get_instance().insert_report(bugTypeId, report);
}

int GVFAVulnerabilityChecker::detectAndReport(
    Module *M, DyckGlobalValueFlowAnalysis *GVFA,
    bool contextSensitive, bool verbose) {
    
    this->GVFA = GVFA;
    int bugTypeId = registerBugType();
    
    VulnerabilitySourcesType Sources;
    VulnerabilitySinksType Sinks;
    getSources(M, Sources);
    getSinks(M, Sinks);
    
    int vulnCount = 0;
    
    for (const auto &SinkPair : Sinks) {
        const Value *SinkValue = SinkPair.first;
        const std::set<const Value *> *SinkInsts = SinkPair.second;
        
        for (const auto &SourceEntry : Sources) {
            const Value *SourceValue = SourceEntry.first.first;
            int SourceMask = SourceEntry.second;
            
            bool reachable = contextSensitive 
                ? GVFA->contextSensitiveReachable(SourceValue, SinkValue)
                : GVFA->reachable(SinkValue, SourceMask);
            
            if (reachable) {
                vulnCount++;
                reportVulnerability(bugTypeId, SourceValue, SinkValue, SinkInsts);
                
                if (verbose) {
                    llvm::outs() << "VULNERABILITY: " << getCategory() << "\n";
                    // Basic verbose output
                }
            }
        }
    }
    
    return vulnCount;
}

