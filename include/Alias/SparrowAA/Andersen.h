//
// This file defines an implementation of Andersen's interprocedural alias
// analysis
//
// In pointer analysis terms, this is a subset-based, flow-insensitive,
// field-sensitive algorithm.  Context sensitivity is configurable: the
// default is context-insensitive, but k-call-site (k-CFA) contexts can
// be enabled at runtime.
//
// This algorithm is implemented as three stages:
//   1. Object identification.
//   2. Inclusion constraint identification.
//   3. Offline constraint graph optimization
//   4. Inclusion constraint solving.
//
// The object identification stage identifies all of the memory objects in the
// program, which includes globals, heap allocated objects, and stack allocated
// objects.
//
// The inclusion constraint identification stage finds all inclusion constraints
// in the program by scanning the program, looking for pointer assignments and
// other statements that effect the points-to graph.  For a statement like "A =
// B", this statement is processed to indicate that A can point to anything that
// B can point to.  Constraints can handle copies, loads, and stores, and
// address taking.
//
// The offline constraint graph optimization portion includes offline variable
// substitution algorithms intended to compute pointer and location
// equivalences.  Pointer equivalences are those pointers that will have the
// same points-to sets, and location equivalences are those variables that
// always appear together in points-to sets.  It also includes an offline
// cycle detection algorithm that allows cycles to be collapsed sooner
// during solving.
//
// The inclusion constraint solving phase iteratively propagates the inclusion
// constraints until a fixed point is reached.  This is an O(N^3) algorithm.
//
// Function constraints are handled as if they were structs with X fields.
// Thus, an access to argument X of function Y is an access to node index
// getNode(Y) + X.  This representation allows handling of indirect calls
// without any issues.  To wit, an indirect call Y(a,b) is equivalent to
// *(Y + 1) = a, *(Y + 2) = b.
// The return node for a function is always located at getNode(F) +
// CallReturnPos. The arguments start at getNode(F) + CallArgPos.
//

#ifndef TCFS_ANDERSEN_H
#define TCFS_ANDERSEN_H

#include "Alias/SparrowAA/Constraint.h"
#include "Alias/SparrowAA/NodeFactory.h"
#include "Alias/SparrowAA/TemplatePtsSet.h"

#include <llvm/ADT/DenseMap.h>
#include <llvm/ADT/DenseSet.h>
#include <llvm/ADT/Hashing.h>
#include <llvm/IR/InstrTypes.h>  // For CallBase
#include <llvm/IR/DataLayout.h>

#include <functional>
#include <string>
#include <map>
#include <vector>

struct ContextPolicy {
  using Context = AndersNodeFactory::CtxKey;
  using ToStringFn = std::string (*)(Context, bool);
  using EvolveFn = Context (*)(Context, const llvm::Instruction *);

  Context (*initialCtx)();
  Context (*globalCtx)();
  EvolveFn evolve;
  ToStringFn toString;
  void (*release)();
  unsigned k;
  const char *name;
};

ContextPolicy makeContextPolicy(unsigned kCallSite);
ContextPolicy getSelectedAndersenContextPolicy();

class Andersen {
private:
  // A factory object that knows how to manage AndersNodes
  AndersNodeFactory nodeFactory;

  // Constraints - This vector contains a list of all of the constraints
  // identified by the program.
  std::vector<AndersConstraint> constraints;

  // This is the points-to graph generated by the analysis
  // Using the DefaultPtsSet from TemplatePtsSet.h
  std::map<NodeIndex, DefaultPtsSet, std::less<NodeIndex>, std::allocator<std::pair<const NodeIndex, DefaultPtsSet>>> ptsGraph;

  ContextPolicy ctxPolicy;
  AndersNodeFactory::CtxKey initialCtx;
  AndersNodeFactory::CtxKey globalCtx;

  struct FunctionContextKey {
    const llvm::Function *func;
    AndersNodeFactory::CtxKey ctx;
  };
  struct FunctionContextInfo {
    static FunctionContextKey getEmptyKey() {
      return {reinterpret_cast<const llvm::Function *>(-1), reinterpret_cast<void *>(0x1)};
    }
    static FunctionContextKey getTombstoneKey() {
      return {reinterpret_cast<const llvm::Function *>(-2), reinterpret_cast<void *>(0x2)};
    }
    static unsigned getHashValue(const FunctionContextKey &k) {
      return llvm::hash_combine(k.func, k.ctx);
    }
    static bool isEqual(const FunctionContextKey &lhs, const FunctionContextKey &rhs) {
      return lhs.func == rhs.func && lhs.ctx == rhs.ctx;
    }
  };
  llvm::DenseSet<FunctionContextKey, FunctionContextInfo> visitedFunctions;

  // Three main phases
  void collectConstraints(const llvm::Module &);
  void collectConstraintsForFunction(const llvm::Function *, AndersNodeFactory::CtxKey);
  void optimizeConstraints();
  void solveConstraints();

  // Helper functions for constraint collection
  void collectConstraintsForGlobals(const llvm::Module &, AndersNodeFactory::CtxKey);
  void collectConstraintsForInstruction(const llvm::Instruction *, AndersNodeFactory::CtxKey);
  void addGlobalInitializerConstraints(NodeIndex, const llvm::Constant *, AndersNodeFactory::CtxKey);
  void addConstraintForCall(const llvm::CallBase *cs, AndersNodeFactory::CtxKey callerCtx);
  bool addConstraintForExternalLibrary(const llvm::CallBase *cs,
                                     const llvm::Function *f, AndersNodeFactory::CtxKey callerCtx);
  void addArgumentConstraintForCall(const llvm::CallBase *cs,
                                  const llvm::Function *f, AndersNodeFactory::CtxKey callerCtx,
                                  AndersNodeFactory::CtxKey calleeCtx);

  // Helper functions for constraint optimization
  NodeIndex getRefNodeIndex(NodeIndex n) const;
  NodeIndex getAdrNodeIndex(NodeIndex n) const;

  // For debugging
  void dumpConstraint(const AndersConstraint &) const;
  void dumpConstraints() const;
  void dumpConstraintsPlainVanilla() const;
  void dumpPtsGraphPlainVanilla() const;

public:
  static char ID;

  explicit Andersen(const llvm::Module &, ContextPolicy policy = makeContextPolicy(0));
  ~Andersen();
  bool runOnModule(const llvm::Module &M);

  // Given a llvm pointer v,
  // - Return false if the analysis doesn't know where v points to. In other
  // words, the client must conservatively assume v can points to everything.
  // - Return true otherwise, and the points-to set of v is put into the second
  // argument.
  bool getPointsToSet(const llvm::Value *v,
                      std::vector<const llvm::Value *> &ptsSet) const;
  bool getPointsToSet(const llvm::Value *v,
                      AndersPtsSet &ptsSet) const;
  // Context-sensitive queries (no cross-context union). Return false if the
  // value has no node in the given context; otherwise fill the supplied set.
  bool getPointsToSetInContext(const llvm::Value *v,
                               AndersNodeFactory::CtxKey ctx,
                               std::vector<const llvm::Value *> &ptsSet) const;
  bool getPointsToSetInContext(const llvm::Value *v,
                               AndersNodeFactory::CtxKey ctx,
                               AndersPtsSet &ptsSet) const;

  // Context utilities for clients that want per-context answers.
  AndersNodeFactory::CtxKey getInitialContext() const { return initialCtx; }
  AndersNodeFactory::CtxKey getGlobalContext() const { return globalCtx; }
  AndersNodeFactory::CtxKey evolveContext(AndersNodeFactory::CtxKey prev,
                                          const llvm::Instruction *I) const {
    return ctxPolicy.evolve(prev, I);
  }
  std::string contextToString(AndersNodeFactory::CtxKey ctx,
                              bool detailed = false) const {
    return ctxPolicy.toString(ctx, detailed);
  }
  // Put all allocation sites (i.e. all memory objects identified by the
  // analysis) into the first arugment
  void
  getAllAllocationSites(std::vector<const llvm::Value *> &allocSites) const;

  friend class AndersenAAResult;
};

#endif
